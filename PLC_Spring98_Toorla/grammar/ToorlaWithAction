grammar Toorla;


@header
{
    import toorla.ast.*;
    import toorla.ast.expression.binaryExpression.*;
    import toorla.ast.expression.value.*;
    import toorla.ast.expression.*;
    import toorla.ast.statement.*;
}


@members
{
    int counter;
    void print()
    {
        System.out.println( "hello" );
    }
}

program returns [Program resProgram]:
    list1=classStar
    newClass=entryClass
    list2=classStar
    {
        $resProgram.classes = $list1.classList;
        $resProgram.classes.add($newClass);
        $resProgram.classes.addAll($list2.classList);
    }
    ;

classStar returns [ArrayList<ClassDeclaration> classList]:
    newClass=classRole
    list=classStar
    {
        $classList = $list.classList;
        $classList.add($newClass.resClass);
    }
    |
    //lamda
    ;

classRole returns [ClassDeclaration resClass]:
    ('class' name=ID ':' { $resClass = new ClassDeclaration($name); }
    | 'class' name=ID 'inherits' parent=ID ':' { $resClass = new ClassDeclaration($name, $parent); } )
        body=classItemStar
        {
            $resClass.members = $body.members;
        }
    'end'
    ;

entryClass returns [EntryClassDeclaration resClass]:
    ('entry' 'class' name=ID ':' { $resClass = new ClassDeclaration($name); }
    | 'class' name=ID 'inherits' parent=ID ':' { $resClass = new ClassDeclaration($name, $parent); } )
        list1=classItemStar
        mainFunc=mainFunc
        list2=classItemStar
        {
            $resClass.members = $list1.members;
            $resClass.members.add(mainFunc.main);
            $resClass.members.addAll($list2..members);
        }
     'end'
     ;

mainFunc returns [MethodDeclaration main]:
    ('public')? 'function' Main '()' 'returns' 'int' ':'
        funcBody
    'end'
    ;

classItemStar returns [ClassMemberDeclaration members]:
    ( field | method ) classItemStar | //lamda
    ;

method returns [MethodDeclaration method]:
    (access=access_modifier 'function' name=ID { method = new MethodDeclaration(name); setAccessModifier($access.access); }
     | 'function' name=ID { method = new MethodDeclaration(name); } )
     '(' argumentList ')' 'returns' type ':'
        funcBody
    'end'
    ;

field:
    access_modifier? 'field' idPlus type ';'
    ;

access_modifier returns [AccessModifier access]:
    'public' { $access = ACCESS_MODIFIER_PUBLIC; }
    | 'private' { $access = ACCESS_MODIFIER_PRIVATE; }
    ;

idPlus:
    ID idStar
    ;

idStar:
    ',' ID idStar | //lamda
    ;

primitiveType:
    'int' | 'string' | 'bool'
    ;

type:
    primitiveType | type'['']'
    ;

argumentList:
    argument argumentStar | //lamda
    ;

argumentStar:
    ',' argument argumentStar | //lamda
    ;

argument:
    ID ':' type
    ;

funcBody:
    statementStar
    ;

statementStar:
    statement statementStar | //lamda
    ;

statement:
    singleStatement ';' | block | ifRole | whileRole
    ;

singleStatement:
    assign | breakRole | continueRole | dec | inc | printRole | returnRole | declaration | singleStatement ';' | //lamda
    ;

declaration:
    'var' assignListPlus
    ;

assignListPlus:
    assignID assignListStar
    ;

assignListStar:
    ',' assignID assignListStar | //lamda
    ;

assignID:
    ID '=' expression
    ;

assign:
    expression '=' expression
    ;

block:
    'begin'
        statementStar
    'end'
    ;

breakRole:
    'break'
    ;

ifRole:
    'if' '(' expression ')' statement |
    'if' '(' expression ')' statement 'else' statement
    ;

//if:
//    matched | unmatched
//    ;
//
//matched:
//    'if' '(' expression ')' matched 'else' matched
//    ;
//
//unmatched:
//    'if' '(' expression ')' statement |
//    'if' '(' expression ')' matched 'else' unmatched
//    ;

continueRole:
    'continue'
    ;

dec:
    expression '--'
    ;

inc:
    expression '++'
    ;

printRole:
    'print' '(' (ID | STRINGCONST | NUMBER) ')'
    ;

returnRole:
    'return' expression
    ;

whileRole:
    'while' '(' expression ')'
        statement
     ;

expression:
    expressionL1 |
    expressionL1 '||' expressionL1
    ;

expressionL1:
    expressionL2 |
    expressionL2 '&&' expressionL1
    ;

expressionL2:
    expressionL3 |
    expressionL3 ( '==' | '<>' ) expressionL2
    ;

expressionL3:
    expressionL4 |
    expressionL4 ( '>' | '<' ) expressionL3
    ;

expressionL4:
    expressionL5 |
    expressionL5 ( '-' | '+' ) expressionL4
    ;

expressionL5:
    expressionL6 |
    expressionL6 ( '/' | '*'  | '%' ) expressionL5
    ;

expressionL6:
    expressionL7 |
    ( '-' | '!' ) expressionL6
    ;

expressionL7:
    singleExpression |
    '(' singleExpression ')'
    ;

singleExpression:
    ID | NUMBER | STRINGCONST
    ;

Main:
    'main'
    ;

ID:
    LETTER (LETTER | NUMBER)*
    ;

LETTER:
    [a-z] | [A-Z]
    ;


STRINGCONST:
    '"' CHARACTER (CHARACTER)* '"'
    ;

NUMBER:
    [1-9][0-9]* | [0]
    ;

CHARACTER:
    [a-z] | [A-Z] | [-] | [+]
    ;

WS:
    [ \t\n] -> skip
    ;

KEYWORD:
    'if' | 'else' | 'bool' | 'string' | 'int' | 'class' | 'function'
    | 'print' | 'private' | 'field' | 'self' | 'false' | 'true' | 'while'
    | 'new' | 'return' | 'elif' | 'returns' | 'break' | 'countine' | 'entry'
    | 'begin' | 'end' | 'public' | 'var' | 'inherits'
    ;


SPECIAL
    :   [:] | [+] | [-] | [*] | [/] | [!] | [%] | [&&] | [||] | [=] | [==] | [,]
      | [[] | [.] | [!] | [<] | [>]
    ;